% Generated by roxygen2: do not edit by hand
% Please edit documentation in R/annotating-mutate.R
\name{mutate_annotation}
\alias{mutate_annotation}
\alias{mutate_annotation_across}
\title{Modify dataset variable annotations}
\usage{
mutate_annotation(.data, .field, ..., .overwrite = TRUE)

mutate_annotation_across(
  .data,
  .field,
  .fn,
  .cols = dplyr::everything(),
  ...,
  .overwrite = TRUE
)
}
\arguments{
\item{.data}{A \code{data.frame}}

\item{.field}{The name of the annotation field that you wish to modify}

\item{...}{For \code{mutate_annotation}, named parameters that contain the annotation
values. Like \code{dplyr::mutate}, each parameter name is a variable
(that must already exist!), and each parameter value is an R expression,
evaluated with \code{.data} as a data mask.

For \code{mutate_annotation_across}, extra arguments passed to \code{.fn}}

\item{.overwrite}{If \code{TRUE}, overwrites existing annotation values.
Annotations have an overwriting guard by default, but since these functions
are intentionally modifying the annotations, this parameter
defaults to \code{TRUE}.}

\item{.fn}{A function that takes in a vector, the currently selected variable}

\item{.cols}{A tidyselect-compatible selection of variables to be edited}
}
\value{
A \code{data.frame} with annotated columns
}
\description{
Usually, metadata should be a reflection of what the data
\emph{should} represent and act as a check on the generation code.
However, in the course of data aggregation, it can be common to
perform massive transformations that would be cumbersome to
document manually. This exposes a metadata-manipulation framework
prior to metadata file creation, in the style of \code{dplyr::mutate}.
}
